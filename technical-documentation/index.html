
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Document</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Libertinus+Math&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <nav id="navbar">
        <header id="nav_header"> Document: DSA with Python</header>
        <ul>
        <li><a class="nav-link" href="#Introduction_to_DSA_with_Python">Introduction to DSA with Python</a></li>
        <li><a class="nav-link" href="#Arrays_and_Lists">Arrays and Lists</a></li>
        <li><a class="nav-link" href="#Stacks">Stacks</a></li>
        <li><a class="nav-link" href="#Queues_and_Deques">Queues and Deques</a></li>
       <li><a class="nav-link" href="#Linked_Lists">Linked Lists</a></li>
        <li><a class="nav-link" href="#Recursion">Recursion</a></li>
        <li><a class="nav-link" href="#Searching_Algorithms">Searching Algorithms</a></li>
        <li><a class="nav-link" href="#Sorting_Algorithms">Sorting Algorithms</a></li>
        <li><a class="nav-link" href="#Hashing_and_Hash_Tables">Hashing and Hash Tables</a></li>
        <li><a class="nav-link" href="#Graphs">Graphs</a></li>
        <li><a class="nav-link" href="#Trees">Trees</a></li>
        <li><a class="nav-link" href="#Time_and_Space_Complexity">Time And Space Complexity</a></li>
        <li><a class="nav-link" href="#Greedy_Algorithms">Greedy Algorithms</a></li>
        <li><a class="nav-link" href="#Dynamic_Programming">Dynamic Programming</a></li>
        <li><a class="nav-link" href="#Conclusion">Conclusion</a></li></ul>



        
    </nav>
    <main id="main-doc">
        <section id="Introduction_to_DSA_with_Python" class="main-section">
            <header>Introduction to DSA with Python</header>
            <p>Data Structures and Algorithms (DSA) form the foundation of computer science. Data Structures are ways to
                store and organize data, while Algorithms are a set of instructions to solve problems. Mastering DSA
                helps you write efficient, optimized, and scalable code. It's particularly useful in coding interviews,
                competitive programming, and high-performance applications. Python is an excellent language for learning
                DSA because of its simple syntax, extensive libraries, and readable code. Python supports both
                high-level abstract data structures like lists, dictionaries, and sets, as well as the ability to
                implement custom data structures such as linked lists, trees, and graphs. With in-built memory
                management and garbage collection, Python allows you to focus more on logic and problem-solving rather
                than language complexities. Python is also widely used in data science and web development, making it a
                versatile choice for DSA learning.</p>
        </section>


        <section id="Arrays_and_Lists" class="main-section">
            <header>Arrays and Lists</header>
            <p>Arrays are collections of elements stored in contiguous memory locations. They allow random access to
                elements and are useful when the size and type of data are known beforehand. Python does not have
                built-in support for arrays like C or Java, but it provides the array module for fixed-type arrays and
                lists for general use. Lists in Python are dynamic arrays that can hold elements of different types and
                resize automatically. Lists support various operations such as insertion, deletion, searching, and
                slicing. They are extremely flexible and commonly used in almost every Python program. Understanding
                arrays and lists is essential for mastering more advanced data structures like stacks, queues, and
                matrices. Lists also support built-in functions such as len(), min(), max(), and slicing operations
                which make data manipulation easy and intuitive. Lists are ideal when you need a container that can grow
                or shrink dynamically, and are a perfect starting point for beginners.
            </p>
            <h4>Example</h4>
            <div class="code">
            <code>arr = [10, 20, 30]<br>
arr.append(40)       # Add at end<br>
arr.remove(20)       # Remove element<br>
print(arr[1])        # Access element<br>
      </code></div>
        </section>


        <section id="Stacks" class="main-section">
            <header>Stacks</header>
            <p>A stack is a linear data structure that follows the Last In First Out (LIFO) principle. This means the
                last element added to the stack will be the first one to be removed. Stacks are commonly used for
                keeping track of function calls, implementing undo mechanisms, and parsing expressions. In Python,
                stacks can be implemented using lists or the deque class from the collections module. When using a list,
                append() is used to push an item and pop() is used to remove it. However, lists are not the most
                efficient for this purpose in terms of time complexity, so deque is preferred in performance-critical
                applications. Understanding stacks is essential because they are the basis of many algorithmic
                techniques like recursion, depth-first search (DFS), and backtracking.
            </p>
            <h4>Example:</h4>
            <div class="code">
            <code>stack = []<br>
stack.append(10)    # Push 10<br>
stack.append(20)    # Push 20<br>
print(stack.pop())  # Pop 20 (LIFO)<br>
      </code>
      </div>
        </section>


        <section id="Queues_and_Deques" class="main-section">
            <header>Queues and Deques</header>
            <p>A queue is a linear data structure that follows the First In First Out (FIFO) principle. The first
                element added to the queue is the first one to be removed. Queues are widely used in real-life scenarios
                like ticketing systems, print queues, and task scheduling. In Python, a basic queue can be implemented
                using a list, but the collections.deque class is more efficient for enqueue and dequeue operations. A
                deque (double-ended queue) allows elements to be added or removed from both ends, making it more
                versatile. Queues support operations like enqueue, dequeue, peek, and checking if empty. Efficient queue
                implementations are essential for breadth-first search (BFS), level-order traversal, and handling
                real-time data streams.</p>
            <h4>Example:</h4>
            <div class="code"><code>from collections import deque<br>
queue = deque()<br>
queue.append(1)      # Enqueue 1<br>
queue.append(2)      # Enqueue 2<br>
print(queue.popleft())  # Dequeue 1 (FIFO)<br></code></div>
        </section>


        <section id="Linked_Lists" class="main-section">
            <header>Linked Lists</header>
            <p>A linked list is a linear data structure where elements are stored in nodes, and each node points to the
                next node in the sequence. Unlike arrays, linked lists do not require contiguous memory and can grow or
                shrink dynamically. There are different types of linked lists: singly linked list, doubly linked list,
                and circular linked list. In a singly linked list, each node has data and a pointer to the next node. In
                a doubly linked list, each node points to both the next and the previous node. Linked lists are useful
                in scenarios where frequent insertion and deletion are required. They form the backbone for advanced
                structures like stacks, queues, and graphs. Understanding how to traverse, insert, and delete nodes in
                linked lists builds a solid foundation for more complex data structures.</p>
            <h4>Example:</h4>
            <div class="code">
            <code>class Node:<br>
    def __init__(self, data):<br>
        self.data = data<br>
        self.next = None<br>

# Creating a simple linked list with one node<br>
a = Node(10)<br>
print(a.data)  # Output: 10<br></code></div>
        </section>


        <section id="Recursion" class="main-section">
            <header>Recursion</header>
            <p>Recursion is a technique in which a function calls itself directly or indirectly. It is used to solve
                problems that can be broken down into smaller, repetitive sub-problems. Every recursive function has two
                main parts: a base case that stops the recursion and a recursive case that continues it. Recursion is
                elegant and closely aligns with mathematical definitions, making some algorithms easier to express. It
                is commonly used in problems like factorial calculation, Fibonacci series, tree traversals, and
                backtracking. However, recursion can be memory intensive, and excessive recursive depth can lead to
                stack overflow errors. Understanding how recursion works, especially the call stack, is crucial for
                writing efficient recursive algorithms.</p>
            <h4>Example:</h4>
            <div class="code">
            <code>def factorial(n):<br>
    if n == 0:<br>
        return 1<br>
    return n * factorial(n - 1)<br></code></div>
        </section>


        <section id="Searching_Algorithms" class="main-section">
            <header>Searching Algorithms</header>
            <p>Searching algorithms are used to find the position or presence of an element in a data structure. The two
                most common types are Linear Search and Binary Search. Linear search checks every element one by one and
                is simple but inefficient for large datasets (O(n)). Binary Search, on the other hand, works only on
                sorted arrays and uses a divide-and-conquer approach, cutting the search space in half with each step
                (O(log n)). Searching is a fundamental part of programming and is used in databases, lookups, and game
                logic. Understanding when and how to use each algorithm is essential for writing efficient programs.</p>
            <h5>Types Of Searching Algorithms</h5>
            <ul>
                <li>Linear Search</li>
                <li>Binary Search</li>
                <li>Interpolation Search</li>
                <li>Exponential Search</li>
                <li>Fibonacci Search</li>
                <li>Ternary Search</li>
                <li>Hash-based Search</li>
                <li>Depth-First Search (for graphs)</li>
                <li>Breadth-First Search (for graphs)</li>
            </ul>
        </section>


        <section id="Sorting_Algorithms" class="main-section">
            <header>Sorting Algorithms</header>
            <p>Sorting algorithms are used to arrange data in a particular order (ascending or descending). Common
                sorting techniques include Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, and Quick Sort.
                These algorithms vary in time complexity and use cases. Simple sorts like Bubble Sort are easy to
                understand but inefficient (O(n^2)), while advanced sorts like Merge Sort and Quick Sort are much faster
                (O(n log n)). Sorting is crucial in many applications like search algorithms, data processing, and user
                interfaces. Mastering various sorting techniques gives insight into algorithm efficiency and data
                handling.</p>
            <ul>
                <li>Bubble Sort</li>
                <li>Selection Sort</li>
                <li>Insertion Sort</li>
                <li>Merge Sort</li>
                <li>Quick Sort</li>
                <li>Heap Sort</li>
                <li>Radix Sort</li>
            </ul>
        </section>


        <section id="Hashing_and_Hash_Tables" class="main-section">
            <header>Hashing and Hash Tables</header>
            <h4>Hashing</h4>
            <p>
                Hashing is a technique used to map data of arbitrary size to data of fixed size using a special function
                called a hash function. The result is a hash value or hash code, which is used as an index to store or
                retrieve values quickly from a data structure like a hash table.
            <h5>Key Concepts:</h5>
            <ol>
                <li>Hash Function:</li>
                <ul>

                    <li>A function that takes a key and returns an integer (called a hash code).</li>

                    <li>Example: <code>hash("apple") → 930292838274</code> (Python's built-in hash function)</li>

                    <li>The hash code is usually compressed using modulo to fit into a fixed size table: index =
                        hash(key) % size.</li>
                </ul>
                <li>Deterministic:</li>
                <ul>
                    <li>The same input always gives the same output.</li>
                </ul>

                <li>Efficiency:</li>
                <ul>
                    <li>Hashing provides average-case O(1) time complexity for insertion, deletion, and search
                        operations.</li>
                </ul>
                <li>Collisions:</li>
                <ul>
                    <li>Occurs when two different keys get the same hash index.</li>

                    <li>Example: "bat" and "tab" might map to the same index.</li>

                    <li>Must be handled using collision resolution techniques.</li>
                </ul>
            </ol>

            <h4>Hash Table</h4>
            A Hash Table is a data structure that stores key-value pairs using a hash function to compute the index into
            an array of buckets or slots.

            <h5>Components:</h5>
            <ol>
                <li>Array (table) - Fixed-size list where data is stored.</li>

                <li>Hash function - Computes an index for each key.</li>

                <li>Collision handling method - Handles multiple keys mapping to the same index.</li>
            </ol>

            <h4>Collision Resolution Techniques</h4>
            <ol>
                <li>Chaining:</li>

                <ul>
                    <li>Each table slot stores a list (or linked list) of all key-value pairs that hash to the same
                        index.</li>

                    <li>Easy to implement using lists in Python.</li>
                </ul>

                <li>Open Addressing:</li>

                <ul>
                    <li>If a collision occurs, find the next available slot using probing:</li>
                    <ul>

                        <ul>
                            <li>Linear probing: index + 1, index + 2, ...</li>

                            <li>Quadratic probing: index + 1^2, index + 2^2, ...</li>

                            </li>Double hashing: Use a second hash function to decide the step size.</li>
                        </ul>
            </ol>
            </p>
        </section>


        <section id="Graphs" class="main-section">
            <header>Graphs</header>
            <p>

            A graph is a non-linear data structure consisting of nodes (vertices) and edges connecting pairs of nodes.
            It can be directed or undirected, weighted or unweighted.

            <h4>Key Terms:</h4>

            <ul>
                <li>Vertices (Nodes): Points in the graph.</li>

                <li>Edges: Connections between vertices.</li>

                <li>Adjacency List: Dictionary where each key has a list of connected nodes.</li>

                <li>Adjacency Matrix: 2D array where matrix[i][j] = 1 if there is an edge from i to j.</li>
            </ul>
            <h4>Traversal:</h4>

            <ul>
                <li>DFS (Depth-First Search): uses stack or recursion</li>

                <li>BFS (Breadth-First Search): uses queue</li>
            </ul>
            </p>
        </section>


        <section id="Trees" class="main-section">
            <header>Trees</header>
            <p>
                A tree is a hierarchical data structure with a root node and child nodes forming a parent-child
                relationship. It's a type of acyclic connected graph.

            <h4>Key Concepts:</h4>
            <ul>

                <li>Binary Tree: Each node has at most 2 children.</li>

                <li>Binary Search Tree (BST): Left < Root < Right.</li>
            </ul>

            <h4>Traversal Types:</h4>

            <ul>
                <li>Inorder (Left → Root → Right)</li>

                <li>Preorder (Root → Left → Right)</li>

                <li>Postorder (Left → Right → Root)</li>
            </ul>
            </p>
        </section>



        <section id="Time_and_Space_Complexity" class="main-section">
            <header>Time and Space Complexity</header>
            <p>Time Complexity describes how the runtime of an algorithm changes with input size.
                Space Complexity describes the amount of memory used as input size increases.

            <ul>
                <li>Big-O Notation: Shows worst-case performance.</li>

                <li>O(1): Constant time</li>

                <li>O(log n): Logarithmic (binary search)</li>

                <li>O(n): Linear</li>

                <li>O(n log n): Efficient sorts (Merge Sort)</li>

                <li>O(n²): Nested loops (Bubble Sort)</li>
            </ul>
            </p>
        </section>


        <section id="Greedy_Algorithms" class="main-section">
            <header>Greedy Algorithms</header>
            <p>A greedy algorithm builds up a solution piece by piece, always choosing the option that looks best at the
                moment (locally optimal).

            <h4>Applications:</h4>

            <ul>
                <li>Activity Selection</li>

                <li>Fractional Knapsack</li>

                <li>Kruskal's Algorithm (MST)</li>
                </p>
        </section>


        <section id="Dynamic_Programming" class="main-section">
            <header>Dynamic Programming</header>
            <p>Dynamic Programming is an optimization technique used for solving complex problems by breaking them into
                simpler overlapping subproblems and solving each subproblem only once (usually storing the result).

            <h4>Key Concepts:</h4>

            <ul>
                <li>Memoization (Top-Down): Uses recursion with caching.</li>

                <li>Tabulation (Bottom-Up): Uses iterative DP table.</li>
            </ul>
            <h4>Example:</h4>
           <div class="code"> <code>def fib(n, memo={}):<br>
    if n <= 1:<br>
        return n<br>
    if n not in memo:<br>
        memo[n] = fib(n-1, memo) + fib(n-2, memo)<br>
    return memo[n]<br>
</code></div></p>
        </section>


        <section id="Conclusion" class="main-section">
            <header>Conclusion</header>
            <p>Understanding and mastering Data Structures and Algorithms (DSA) is essential for writing efficient, scalable, and optimized code. Throughout this document, we have explored foundational and advanced concepts such as graphs, trees, heaps, time and space complexity, greedy algorithms, and dynamic programming. Each of these topics plays a crucial role in solving real-world problems and improving the performance of applications.

Graphs and trees help in modeling relationships and hierarchies. Heaps and priority queues are vital for scheduling and optimization problems. Analyzing time and space complexity allows us to predict algorithm performance. Greedy algorithms offer simple yet powerful solutions by making locally optimal choices, while dynamic programming enables us to solve complex problems by reusing solutions to subproblems.

By understanding how and when to apply these techniques in Python, one can build strong logical thinking and problem-solving skills. Together, these concepts form the backbone of computer science and software engineering, making them indispensable tools for every programmer and developer.</p>
        </section>
    </main>
</body>

</html>